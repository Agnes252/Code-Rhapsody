---
title: 链表
date: 2026-01-09 20:34:31
tags: [算法, 链表]
---

## 链表：基础知识

链表是一种通过指针串联在一起的线性结构。每一个节点由两部分组成，一个是数据域(data)，一个是指针域（next, 存放指向下一个节点的指针），最后一个节点的指针域指向null。

### 链表的类型

- 单链表

  ![image-20260109104033812](D:\MyCode\Code_Rhapsody\source\_posts\image-20260109104033812.png)

- 双链表

  每一个节点有两个指针域（prev, next）。从而，双链表既可以向前查询也可以向后查询。

  ![image-20260109104145325](D:\MyCode\Code_Rhapsody\source\_posts\image-20260109104145325.png)

- 循环链表

  首尾相连的链表。οὐροβόρος.

### 链表的存储方式

链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，通过指针串连在一起。节点地址的分配机制取决于操作系统的内存管理。

### 链表的性能分析

![image-20260109112008516](D:\MyCode\Code_Rhapsody\source\_posts\image-20260109112008516.png)

### 链表的操作

- 定义链表构造函数

  ```c++
  // 单链表
  struct ListNode {
      int val; // 节点上存储的元素
      ListNode *next; // 指向下一个节点的指针
      ListNode(int x): val(x), next(NULL) {} // 节点的构造函数
  }
  
  ListNode* head = new ListNode(5); // 通过自定义构造函数初始化节点
  
  ListNode* head = new ListNode();
  head -> val = 5; // 使用默认构造函数初始化节点(无法在初始化时赋值)
  ```

  ```python
  # 节点
  class Node:
      def __init__(self, data):
          self.data = data
          self.next = None
  
  # 链表类
  class LinkedList:
  	def __init__(self):
  		self.head = None
      def insert_at_head(self, data):
          """在链表头部插入新节点"""
          new_node = Node(data)
          new_node.next = self.head
          self.head = new_node
      def append(self, data):
          """在链表尾部插入新节点"""
          new_node = Node(data)
          if not self.head:
              self.head = new_node
              return
          last = self.head # 寻找当前的尾节点 o(n)
          while last.next:
              last = last.next
          last.next = new_node # 挂载新节点
          
  llist = LinkedList()
  llist.append(10)
  ```

- 移除链表元素

  采用虚拟头节点法，在原head前增加一个dummy_head，从而遍历时对head.data == val的情况不需要做edge case处理。

  ```python
  class ListNode:
      def __init__(self, val=0, next=None):
          self.val = val
          self.next = next
          
  class Solution:
  	def removeElements(self, head: Optional[ListNode], val:int) -> Optional[ListNode]:
          # 创建dummy head以简化删除过程
          dummy_head = ListNode(next = head)
          # 遍历列表并删除值为val的节点
          current = dummy_head # link: Python v.s. C++: 内存管理
          while current.next:
              if current.next.val == val:
                  current.next = current.next.next # 写操作：修改了current所指向的实体对象(current = dummy_head = ListNode(next=head))的属性！
              else:
                  current = current.next # 读操作+重绑定：只是移动标签current指向新地址(next)
                  
          return dummy_head.next
  ```

- 备注：对Python的“引用语义”和“指针偏移”的理解

  - 在 Python 链表代码中，`current = dummy_head` 意味着 `current` 成了 `dummy_head` 的**别名**。
  - 修改 `current.next` 等同于修改 `dummy_head.next`（修改的是同一个内存块的属性）。
  - 执行 `current = current.next` 是**标签移动**：将 `current` 标签撕下来，贴到下一个节点上。此时它与 `dummy_head` 脱离绑定关系，但之前的修改已永久生效。

## 设计链表

> 在链表类中实现这些功能：
>
> - 获取链表第index个节点的数值
> - 在链表的最前面插入一个节点
> - 在链表的最后面插入一个节点
> - 在链表第index个节点前面插入一个节点
> - 删除链表的第index个节点

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class MyLinkedList:
    def __init__(self):
        self.dummy_head = ListNode()
        self.size = 0
        
    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        
        current = self.dummy_head.next
        for i in range(index):
            current = current.next
            
        return current.val
    
    def addAtHead(self, val:int) -> None:
        self.dummy_head.next = ListNode(val, self.dummy_head.next)
        self.size += 1
        
```

