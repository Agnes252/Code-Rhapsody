---
title: 数组
date: 2026-01-09 20:34:31
tags: [算法, 数组]
---

**数组是存放在连续内存空间上的相同类型数据的集合。**通过下标索引，可以方便地获取到下标对应的数据。

## 二分法

> 问题：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。（704）

二分法适用场景：有序数组+无重复元素

Notes：定义循环不变量（在此题即数组），确定 [ ] 或 [ ) 

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]

        while left <= right:
            middle = left + (right - left) // 2
            
            if nums[middle] > target:
                right = middle - 1  # target在左区间，所以[left, middle - 1]
            elif nums[middle] < target:
                left = middle + 1  # target在右区间，所以[middle + 1, right]
            else:
                return middle  # 数组中找到目标值，直接返回下标
        return -1  # 未找到目标值
```

## 移除元素（双指针法）

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。

双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 快慢指针
        fast, slow = 0, 0 # 两个指针起始位置
        size = len(nums)
        while fast <= size - 1:
            # slow 用来收集不等于 val 的值, fast用来遍历nums所有元素
            if nums[fast] != val: # 思考这里为什么是!=不是==
                nums[slow] = nums[fast]
                slow += 1
               fast += 1
        return slow
```

## 有序数组的平方

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1：
>
> - 输入：nums = [-4,-1,0,3,10]
> - 输出：[0,1,9,16,100]
> - 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

最终输出要求按非递减排序，等价与按非递增顺序排序。max(平方)一定要么出现在数组最左侧，要么在最右侧。因此可以用双指针法做。

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        l, r = 0, len(nums) - 1 # 左指针和右指针
        i = len(nums) - 1
        result = []
        while l <= r:
            if nums[l]**2 >= nums[r]**2:
                result[i] = nums[l]**2
                l += 1
            else:
                result[i] = nums[r]**2
                r -= 1
            i -= 1
        return result
```

## *长度最小的子数组（滑动窗口）

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。（209）
>
> 示例：
>
> - 输入：s = 7, nums = [2,3,1,2,4,3]
> - 输出：2
> - 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

滑动窗口：不断的调节子序列的起始位置和终止位置，本质上是一种双指针法。

由于每个元素在进、出滑动窗口时各操作一次，时间复杂度为O(2*n) = O(n)。

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l = len(nums)
        left, right = 0, 0
        min_len = float('inf')
        sum = 0
        
        while right < l: 
            sum += nums[right]
            while sum >= s:
                min_len = min(min_len, right - left + 1)
                sum -= nums[left]
                left += 1
            right += 1
        
        return min_len if min_len != float('inf') else 0   
```

## 螺旋矩阵II（窗口选择；循环不变量）

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。（59）
>
> 示例:
>
> 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        x, y = 0, 0 # 每一层的左上起始坐标点
        i = n - 1 # 边长
        count = 0 # 已填充格子数
        nums = range(1, n**2 + 1) # 用于填充的数据
        matrix = [[0]*n for _ in range(n)] # 返回n*n正方形矩阵

        while i >= 1: # 边长最后为2, 1或3, 1
            # 左上到右上
            for k in range(i):
                matrix[x][y+k] = nums[count]
                count += 1
            # 右上到右下
            for k in range(i):
                matrix[x+k][y+i] = nums[count]
                count += 1
            # 右下到左下
            for k in range(i):
                matrix[x+i][y+i-k] = nums[count]
                count += 1
            # 左下到左上
            for k in range(i):
                matrix[x+i-k][y] = nums[count]
                count += 1

            i -= 2 #边长减2
            x += 1 
            y += 1

        if n%2 == 1: # 如果是奇数，填充最终的中心点
            matrix[x][y] = nums[-1]
        return matrix 
```

## 区间和

> 给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。
>
> 输入：第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。
>
> 输出：每个指定区间内元素的总和。（58）

**前缀和 在涉及计算区间和的问题上非常有用**。

原理：求vec[2]到vec[5]的元素和，可以用sum[5] - sum[1]。

另外，此题涉及**输入读取(ACM输入输出模式)**。

```python
import sys
input = sys.stdin.read

def main():
    data = input().split()
    index = 0 # 输入读取位置（第几行）
    n = int(data[index])
    index += 1
    vec = []
    for i in range(n):
        vec.append(int(data[index+i])) #基于输入构建数组
    index += n # 读取到了第n行
    
    p = [0]*n #记录前缀和
    presum = 0
    for i in range(n):
        presum += vec[i]
        p[i] = presum
        
    results = [] # 根据输入，计算指定区间的和
    while index < len(data):
        a = int(data[index])
        b = int(data[index + 1])
        index += 2
        
        if a == 0:
            sum_value = p[b]
        else:
            sum_value = p[b] - p[a-1] # 注意是a-1
        
        results.append(sum_value)
        
    for result in results:
        print(result)
        
if __name__ == "__main__":
    main()
```

## 开发商购买土地

> 在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。
>
> 现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
>
> 然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。
>
> 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。
>
> 输入：第一行输入两个正整数，代表n和m；接下俩输入n*m矩阵。
>
> 输出：一个整数，代表两个子区域内土地总价值之间的最小差距



```python
import sys
input = sys.stdin.read

def main():
    data = input().split()
    
    idx = 0 # 读取输入数据位置的标记
    n = int(data[idx])
    idx += 1
    m = int(data[idx])
    idx += 1
    sum = 0
    vec = []
    
    for i in range(n):
        row = []
        for j in range(m):
            num = int(data[idx])
            idx += 1
            row.append(num)
            sum += num
        vec.append(row)
        
    # 前缀和思想。统计横向和
    horizontal = [0] * n
    for i in range(n):
        for j in range(m):
            horizontal[i] += vec[i][j]
            
    # 统计纵向
    vertical = [0] * m
    for j in range(m):
        for i in range(n):
            vertical[j] += vec[i][j]
            
    result = float('inf')
    area = 0
    for i in range(n):
        area += horizontal[i]
        result = min(result, abs(sum - 2*area))
        
    area = 0
    for j in range(m):
        area += vertical[j]
        result = min(result, abs(sum - 2*area))
        
    print(result)
    
if __name__ == "__main__":
    main()
```

